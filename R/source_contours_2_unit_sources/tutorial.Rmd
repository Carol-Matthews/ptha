```{r cache=FALSE, eval=TRUE, echo=FALSE}
# Turn off warnings
options(warn=-1) # Don't do this !
knitr::read_chunk(
    'produce_unit_sources.R', 
    labels=c('initialise'), 
    from=c('## ---- initialise ----'), 
    to=c('## ---- makeDiscretizedSources ----'),
    from.offset=1,
    to.offset=-1)
```

# **Making unit sources from contours defining the earthquake source geometry**
------------------------------------------------------------------------------

*Note: Do not edit the tutorial.md file directly, as it is auto-generated by the
corresponding tutorial.Rmd file. Edit the latter instead.*

# Background

This document explains how to use the script
*'[produce_unit_sources.R](produce_unit_sources.R)'* to convert earthquake
source contours (defining an irregularly dipping surface on which earthquake
slip can occur) into unit sources. It also provides some explanation
of the data structures used.

You may find it helpful to directly read
*'[produce_unit_sources.R](produce_unit_sources.R)'* first (or instead),
particularly if you have programming experience. All functions used therein are
documented in the rptha package or other packages, and so R's help system can
be consulted for details. 

In a typical application you would make a copy of *'[produce_unit_sources.R](produce_unit_sources.R)'* in a
new working directory, and then edit the script parameters as required before
running. You might also edit the code, depending on your needs.

To create a set of unit sources, you first need to have a set of source
contours. These describe the earthquake source geometry, which we will
discretize into unit sources. The source contours need to be in line shapefile
format, where each line corresponds to a contour with given depth. The actual
depths are stored in the shapefile attribute table, with an attribute name
'level' giving the depth in km.  Lon-lat coordinates should be used (WGS84).

The source contours will be used to define the unit sources, so they should
only cover areas where you want unit sources to be made. On a typical
subduction zone they would extend from the subduction zone trench to a depth
of around 50 km, though the latter depth may vary (see e.g.  Berryman et al.,
2015). 

The unit sources will be arranged in a logically rectangular grid which covers
the source contours. The number of unit-sources down-dip and along-strike is chosen
based on the user-provided value for the desired unit-source length and width. 

# Example data

In this example we work with some contours for the Alaska source-zone. This is
situated at the eastern end of the Aleutians-Alaska subduction interface in the
North Pacific. The code below demonstrates how to read them in R and make a basic plot. 

**Note the code in this section is not required when using
*'[produce_unit_sources.R](produce_unit_sources.R)'* -- however, we include
this to demonstrate the input data requirements**

```{r, eval=TRUE, echo=TRUE}
# Read the shapefile
library(rgdal)
alaska = readOGR(dsn='CONTOURS/alaska.shp', layer='alaska')

# Print some information about it
print(alaska)

# There should be a single attribute named 'level' containing the contour depths
names(alaska)
print(alaska$level)

# The print out above shows that R has read 'level' as a factor (a categorical
# type variable). Let's convert it to numeric
alaska$level = as.numeric(as.character(alaska$level))
print(alaska$level) # No longer a factor

# Make a quick plot of the input data
spplot(alaska, main='Alaska sourcezone contours giving the interface depth in km', 
    scales=list(draw=TRUE), aspect='iso')
```

# Input parameters

The code below comes directly from *'[produce_unit_sources.R](produce_unit_sources.R)'*.

In typical usage of *'[produce_unit_sources.R](produce_unit_sources.R)'*, the user would edit the input
parameters to define the source contour filename(s), the desired unit-source
length and width, the resolution of the output raster, and some numerical
parameters describing the density of sub-unit-source gridpoints inside each unit
source.

Note that more than one source-contour shapefile can be provided -- the code
will loop over them.

If you are running linux on a shared memory machine with multiple cores, then
you can run in parallel by setting MC_CORES to be a number greater than one. In this
case each core will run separate unit sources, until all are completed. 

```{r initialise, echo=TRUE}
```

# Outputs

If the code successfully runs, it will generate: 
* a set of tiff files (one for each unit source) with the computed tsunami deformation. 
* a pdf file for each sourcezone, with various plots that can be used to check
that the unit sources and tsunami deformations seem sensible.
* an RDS file for each sourcezone. This is a native R format file, and contains
the tsunami unit sources as a native R data-structure. It can be useful for
programming, since it contains the underlying data (such as sub-unit-source
points, exact unit source discretization, etc).

<!---
# Geometric discretization

Here we create the unit source geometry. The computation of the tsunami
deformation comes later. The key step is the function call
*discretized_source_from_source_contours* which converts source contours
to a list of unit sources.


```{r makeDiscretizedSources, echo=TRUE}
```

The above figures illustrate that the source contours are converted to a logically
retangular grid of unit sources.

# Further exploration of the data structures

Here we explore the unit source data structures in more detail. Perhaps the
most important point is that the unit source grid is stored as a 3d array.

```{r}
# discretized_sources is a list containing unit source information for each sourcezone.
length(discretized_sources) # Should be equal to the number of input shapefiles
names(discretized_sources)

# Taking the example of alaska, we look at the unit source information for a single source
names(discretized_sources$alaska)

# The depth contours are as before
plot(discretized_sources$alaska$depth_contours, asp=1, axes=TRUE)

# The unit sources are in a grid of these dimensions down-dip and along-strike 
discretized_sources$alaska$discretized_source_dim
ndip = discretized_sources$alaska$discretized_source_dim['dip']
nstrike = discretized_sources$alaska$discretized_source_dim['strike']

# The unit source grid is represented as a 3d array of x,y,depth points. These
# define the boundaries of the unit sources. Obviously there must be 'ndip+1'
# lines down dip, and 'nstrike+1' lines along-strike
#
# First dimension: Down-dip
# Second dimension: x,y,z
# Third dimension: Along-strike
#
dim(discretized_sources$alaska$unit_source_grid)

discretized_sources$alaska$unit_source_grid

# Add to the plot
for(j in 1:(nstrike+1)) points(discretized_sources$alaska$unit_source_grid[,1:2,j], t='o', col='red')
for(j in 1:(ndip+1)) points(t(discretized_sources$alaska$unit_source_grid[j,1:2,]), t='o', col='red')

```


# Tsunami deformation

Finally we compute the tsunami initial condition for each unit source.

```{r makeTsunamiSources, echo=TRUE}
```

--->
