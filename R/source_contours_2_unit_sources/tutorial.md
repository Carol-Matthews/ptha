

# **Making unit sources from contours defining the earthquake source geometry**
------------------------------------------------------------------------------

*Note:* Do not edit the tutorial.md file directly, as it is auto-generated by the
corresponding tutorial.Rmd file. Edit the latter instead.

# Background

This document explains how to use the script *'produce_unit_sources.R'* to
convert earthquake source contours (defining an irregularly dipping surface on
which earthquake slip can occur) into unit sources. It also provides some explanation
of the data structures used.

You may find it helpful to directly read *'produce_unit_sources.R'* first (or
instead), particularly if you have programming experience. All functions used
therein are documented in the rptha package or other packages, and so R's help
system can be consulted for details. 

In a typical application you would make a copy of *'produce_unit_sources.R'* in a
new working directory, and then edit the script parameters as required before
running. You might also edit the code, depending on your needs.

To create a set of unit sources, you first need to have a set of source
contours. These describe the earthquake source geometry, which we will
discretize into unit sources. The source contours need to be in line shapefile
format, where each line corresponds to a contour with given depth. The actual
depths are stored in the shapefile attribute table, with an attribute name
'level' giving the depth in km.  Lon-lat coordinates should be used (WGS84).

The source contours will be used to define the unit sources, so they should
only cover areas where you want unit sources to be made. On a typical
subduction zone they would extend from the subduction zone trench to a depth
of around 50 km, though the latter depth may vary (see e.g.  Berryman et al.,
2015). 

The unit sources will be arranged in a logically rectangular grid which covers
the source contours. The number of unit-sources down-dip and along-strike is chosen
based on the user-provided value for the desired unit-source length and width. 

# Example data

In this example we work with some contours for the Alaska source-zone. This is
situated at the eastern end of the Aleutians-Alaska subduction interface in the
North Pacific. The code below demonstrates how to read them in R and make a basic plot. 

**Note the code in this section is not required when using
*'produce_unit_sources.R'* -- however, we include this to demonstrate the input
data requirements**


```r
# Read the shapefile
library(rgdal)
alaska = readOGR(dsn='CONTOURS/alaska.shp', layer='alaska')
```

```
## OGR data source with driver: ESRI Shapefile 
## Source: "CONTOURS/alaska.shp", layer: "alaska"
## with 10 features
## It has 1 fields
```

```r
# Print some information about it
alaska
```

```
## class       : SpatialLinesDataFrame 
## features    : 10 
## extent      : 204.4529, 215.5272, 55.6071, 61.83479  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
## variables   : 1
## names       : level 
## min values  :    16 
## max values  :     6
```

```r
# There should be a single attribute named 'level' containing the contour depths
names(alaska)
```

```
## [1] "level"
```

```r
print(alaska$level)
```

```
##  [1] 6      16     21     26     31     36     41     46     51     55.999
## Levels: 16 21 26 31 36 41 46 51 55.999 6
```

```r
# The print out above shows that R has read 'level' as a factor (a categorical
# type variable). Let's convert it to numeric
alaska$level = as.numeric(as.character(alaska$level))
print(alaska$level) # No longer a factor
```

```
##  [1]  6.000 16.000 21.000 26.000 31.000 36.000 41.000 46.000 51.000 55.999
```

```r
# Make a quick plot of the input data
spplot(alaska, main='Alaska sourcezone contours giving the interface depth in km', 
    scales=list(draw=TRUE), aspect='iso')
```

![plot of chunk unnamed-chunk-2](figure/unnamed-chunk-2-1.png) 

# Input parameters

The code below comes directly from *'produce_unit_sources.R'*.

In typical usage of *'produce_unit_sources.R'*, the user would edit the input
parameters to define the source contour filename(s), the desired unit-source
length and width, the resolution of the output raster, and some numerical
parameters describing the density of sub-unit-source gridpoints inside each unit
source.

Note that more than one source-contour shapefile can be provided -- the code
will loop over them.

If you are running linux on a shared memory machine with multiple cores, then
you can run in parallel by setting MC_CORES to be a number greater than one. In this
case each core will run separate unit sources, until all are completed. 


```r
# Main 'driver' script to create the unit sources (currently pure thrust events
# only)
#
# Gareth Davies, Geoscience Australia 2015
#
library(rptha)
###############################################################################
#
# Main input parameters 
#
###############################################################################

# A vector with shapefile names for all contours that we want to convert to
# unit sources
all_sourcezone_shapefiles = Sys.glob('./CONTOURS/*.shp') # Matches all shapefiles in CONTOURS

# Desired unit source geometric parameters
desired_subfault_length = 100 # km
desired_subfault_width = 50 # km

# Desired spacing of sub-unit-source points
# Lower values (e.g. 1000) may be required for accuracy in unit sources
# along the trench, but in deeper unit sources a coarser point spacing
# can be used. Hence 2 different values are provided.
# The computational effort approximately scales with the inverse square of
# the point density. 
shallow_subunitsource_point_spacing = 1000 # m
deep_subunitsource_point_spacing = 6000 #m

# For computational efficiency, only compute the okada deformation at
# distances <= okada_distance_factor x (depth of sub-unit-source point) 
# This can save computational effort for shallow unit sources.
# But be careful if using a wide subunitsource_point_spacing.
okada_distance_factor = 50 # Inf 

# Cell size for output rasters
tsunami_source_cellsize = 1/60 # degrees

# Number of cores for parallel parts. Values > 1 will only work on shared
# memory linux machines.
MC_CORES = 12 

# Option to illustrate 3d interactive plot creation
#
# Only make the 3d interactive plot if you can use interactive graphics and
# have rgl (i.e. use FALSE on NCI). 
make_3d_interactive_plot = FALSE 
```

# Outputs

If the code successfully runs, it will generate: 
* a set of tiff files (one for each unit source) with the computed tsunami deformation. 
* a pdf file for each sourcezone, with various plots that can be used to check
that the unit sources and tsunami deformations seem sensible.
* an RDS file for each sourcezone. This is a native R format file, and contains
the tsunami unit sources as a native R data-structure. It can be useful for
programming, since it contains the underlying data (such as sub-unit-source
points, exact unit source discretization, etc).

<!---
# Geometric discretization

Here we create the unit source geometry. The computation of the tsunami
deformation comes later. The key step is the function call
*discretized_source_from_source_contours* which converts source contours
to a list of unit sources.




The above figures illustrate that the source contours are converted to a logically
retangular grid of unit sources.

# Further exploration of the data structures

Here we explore the unit source data structures in more detail. Perhaps the
most important point is that the unit source grid is stored as a 3d array.


```r
# discretized_sources is a list containing unit source information for each sourcezone.
length(discretized_sources) # Should be equal to the number of input shapefiles
```

```
## [1] 1
```

```r
names(discretized_sources)
```

```
## [1] "alaska"
```

```r
# Taking the example of alaska, we look at the unit source information for a single source
names(discretized_sources$alaska)
```

```
## [1] "depth_contours"         "unit_source_grid"      
## [3] "discretized_source_dim" "fine_downdip_transects"
```

```r
# The depth contours are as before
plot(discretized_sources$alaska$depth_contours, asp=1, axes=TRUE)

# The unit sources are in a grid of these dimensions down-dip and along-strike 
discretized_sources$alaska$discretized_source_dim
```

```
##    dip strike 
##      6      7
```

```r
ndip = discretized_sources$alaska$discretized_source_dim['dip']
nstrike = discretized_sources$alaska$discretized_source_dim['strike']

# The unit source grid is represented as a 3d array of x,y,depth points. These
# define the boundaries of the unit sources. Obviously there must be 'ndip+1'
# lines down dip, and 'nstrike+1' lines along-strike
#
# First dimension: Down-dip
# Second dimension: x,y,z
# Third dimension: Along-strike
#
dim(discretized_sources$alaska$unit_source_grid)
```

```
## [1] 7 3 8
```

```r
discretized_sources$alaska$unit_source_grid
```

```
## , , 1
## 
##          [,1]     [,2]     [,3]
## [1,] 215.5563 59.56251  6.00000
## [2,] 214.7280 59.95473 18.02007
## [3,] 213.8749 60.34391 28.53238
## [4,] 212.9955 60.73003 36.73537
## [5,] 212.0873 61.11337 40.21790
## [6,] 211.1588 61.48978 45.82368
## [7,] 210.2165 61.85637 55.99900
## 
## , , 2
## 
##          [,1]     [,2]     [,3]
## [1,] 214.2323 58.98425  6.00000
## [2,] 213.4988 59.34748 14.36937
## [3,] 212.7540 59.70441 25.14984
## [4,] 211.9890 60.05897 34.68086
## [5,] 211.1992 60.41265 40.08028
## [6,] 210.3917 60.76174 45.72060
## [7,] 209.5752 61.10233 55.99900
## 
## , , 3
## 
##          [,1]     [,2]     [,3]
## [1,] 213.1594 58.29439  6.00000
## [2,] 212.4897 58.64639 14.19557
## [3,] 211.8073 58.99442 23.18982
## [4,] 211.1054 59.34157 29.37697
## [5,] 210.3867 59.68597 34.43593
## [6,] 209.6548 60.02562 40.98071
## [7,] 208.9301 60.35126 55.99900
## 
## , , 4
## 
##          [,1]     [,2]     [,3]
## [1,] 212.1371 57.59233  6.00000
## [2,] 211.5080 57.94210 11.77474
## [3,] 210.8664 58.28881 17.55797
## [4,] 210.2108 58.63295 22.83224
## [5,] 209.5426 58.97347 28.53926
## [6,] 208.8709 59.30576 39.59093
## [7,] 208.2036 59.62619 55.99900
## 
## , , 5
## 
##          [,1]     [,2]     [,3]
## [1,] 210.9209 56.99379  6.00000
## [2,] 210.4030 57.31148 11.71131
## [3,] 209.8773 57.62632 18.18387
## [4,] 209.3449 57.93748 26.59440
## [5,] 208.8030 58.24654 35.19962
## [6,] 208.2535 58.55226 44.93815
## [7,] 207.6971 58.85410 55.99900
## 
## , , 6
## 
##          [,1]     [,2]     [,3]
## [1,] 209.5490 56.52478  6.00000
## [2,] 209.0581 56.83396 12.04796
## [3,] 208.5594 57.14096 18.46195
## [4,] 208.0530 57.44560 25.62105
## [5,] 207.5390 57.74768 33.52988
## [6,] 207.0189 58.04618 42.92923
## [7,] 206.5005 58.33671 55.99900
## 
## , , 7
## 
##          [,1]     [,2]     [,3]
## [1,] 208.1063 56.14067  6.00000
## [2,] 207.6567 56.43068 12.18510
## [3,] 207.1994 56.71959 17.90412
## [4,] 206.7339 57.00745 23.22001
## [5,] 206.2625 57.29280 29.63097
## [6,] 205.7900 57.57265 39.05795
## [7,] 205.3381 57.83474 55.99900
## 
## , , 8
## 
##          [,1]     [,2]     [,3]
## [1,] 206.8368 55.61077  6.00000
## [2,] 206.4469 55.88001 10.95392
## [3,] 206.0516 56.14801 15.90784
## [4,] 205.6513 56.41438 21.54216
## [5,] 205.2496 56.67672 29.60462
## [6,] 204.8491 56.93334 40.38060
## [7,] 204.4614 57.17732 55.99900
```

```r
# Add to the plot
for(j in 1:(nstrike+1)) points(discretized_sources$alaska$unit_source_grid[,1:2,j], t='o', col='red')
for(j in 1:(ndip+1)) points(t(discretized_sources$alaska$unit_source_grid[j,1:2,]), t='o', col='red')
```

![plot of chunk unnamed-chunk-3](figure/unnamed-chunk-3-1.png) 


# Tsunami deformation

Finally we compute the tsunami initial condition for each unit source.



--->
